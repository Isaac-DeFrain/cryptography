"""
Modular arithmetic
"""

from extended_euclidean_algorithm import *

class Mod:
    """
    Modular arithmetic functions
    """

    def __init__(self, n: int):
        """
        Initialize the object
        """
        self.n = n

    def is_unit(self, x:int) -> bool:
        """
        Check if x is a unit in Z/nZ
        """
        gcd, _, _ = eea(x, self.n)
        return gcd == 1

    def all_units(self) -> list[int]:
        """
        List of all units of Z/nZ
        """
        n = self.n
        return list(filter(lambda x: self.is_unit(x), range(1, n)))

    def inverse(self, x:int) -> int:
        """
        Inverse of x modulo n using Extended Euclidean algorithm

        Return `0` if and only if `gcd != 1`
        """
        n = self.n
        gcd, a, _ = eea(x, n)
        if gcd != 1:
            return 0
        else:
            return a % n

    def sqrt(self, r: int) -> list[int]:
        """
        Find all solutions `x` to the congruence: `x^2 = r (mod n)`
        """
        n = self.n
        res = []
        for x in range(n):
            if x ** 2 % n == r % n: res.append(x)
        return res

    def order(self, x:int) -> int:
        """
        Order of an element in `Z/nZ`

        Return -1 if `x` is not a unit in `Z/nZ`
        """
        n = self.n
        res = -1
        gcd, _, _ = eea(x, n)
        if gcd != 1: return res
        else:
            for p in range(1, n - 1):
                if pow(x, p, n) == 1:
                    res = p
                    break
            return res

    def generated_group(self, x:int) -> list[int]:
        """
        The group generated by the unit `x` in `Z/nZ`

        `<x> := { pow(x, i, n) : i in range(n) }`
        """
        n = self.n
        group = [x]
        for p in range(2, n):
            y = pow(x, p, n)
            if not group.__contains__(y):
                group.append(y)
            else:
                break
        return sorted(group)

    def check(self, x:int) -> bool:
        """
        Order of <x> = order of x in Z/nZ
        """
        n = self.n
        if not self.is_unit(x):
            raise ValueError(f'{x} is not a unit of Z/{n}Z')
        return self.order(x) == len(self.generated_group(x))
